//
//  Identity.swift
//  poietic-core
//
//  Created by Stefan Urbanek on 25/09/2025.
//

/// Protocol for entity identity types. Provides information about the concrete type.
///
public protocol EntityTypeProtocol {
    static var identityType: IdentityType { get }
}

///
// FIXME: [IMPORTANT] Rename to EntityType, to be more flexible/reusable (such as in loader)
// FIXME: Also rename all properties/functions identityType -> entityType

public enum IdentityType: Sendable, CustomStringConvertible {
    /// Unique within design.
    case objectSnapshot
    /// Unique within design.
    case frame
    /// Unique within frame, can be multiple within design. Used in references.
    case object
    // case track
    
    public var description: String {
        switch self {
        case .objectSnapshot: "objectSnapshot"
        case .frame: "frame"
        case .object: "object"
        }
    }
}

public enum ObjectEntityType: EntityTypeProtocol {
    public static let identityType: IdentityType = .object
}
public enum ObjectSnapshotEntityType: EntityTypeProtocol {
    public static let identityType: IdentityType = .objectSnapshot
}
public enum FrameEntityType: EntityTypeProtocol {
    public static let identityType: IdentityType = .frame
}

public typealias EntityIDValue = UInt64
/// Generic for entity identities.
///
/// This generic structure is used to create typed identities of entities such as objects,
/// object snapshots or design snapshots.
///
/// See concrete types: ``ObjectID``, ``ObjectSnapshotID`` and ``DesignSnapshotID``.
///
public struct EntityID<EntityType: EntityTypeProtocol>:
    Hashable,
    Codable,
    Sendable,
    RawRepresentable,
    ExpressibleByIntegerLiteral,
    CustomStringConvertible
{
    /// Raw value of all object identities.
    ///
    /// This value is wrapped in ``EntityID`` structure and is generated by ``IdentityManager``.
    ///
    /// - SeeAlso: ``EntityID``, ``IdentityManager``
    ///
    public typealias RawValue = EntityIDValue
    public typealias IntegerLiteralType = UInt64
    public private(set) var rawValue: RawValue
    
    public init(rawValue: RawValue) {
        self.rawValue = rawValue
    }
    
    public init(integerLiteral value: Self.IntegerLiteralType) {
        self.rawValue = value
    }
    
    public init?(_ string: String) {
        guard let value = UInt64(string) else { return nil }
        self.rawValue = value
    }
    
    public var stringValue: String { String(rawValue) }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()

        self.rawValue = try container.decode(RawValue.self)
    }
    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(rawValue)
    }
    public var description: String { stringValue }

    @inlinable
    public static func ==(lhs: EntityID<EntityType>, rhs: EntityID<EntityType>) -> Bool {
        return lhs.rawValue == rhs.rawValue
    }
    @inlinable
    public func hash(into hasher: inout Hasher) {
        rawValue.hash(into: &hasher)
    }
}

/// Identity of a design object.
///
/// Design object identity is unique within design snapshot. One design object might have multiple
/// objet snapshots.
///
public typealias ObjectID = EntityID<ObjectEntityType>

/// Identity of a design object snapshot - a version of a design object.
///
/// Design object snapshot is unique within design and within a design snapshot.
///
public typealias FrameID = EntityID<FrameEntityType>

/// Identity of a design snapshot - version of a design.
///
/// Design snapshot ID is unique within design.
///
public typealias ObjectSnapshotID = EntityID<ObjectSnapshotEntityType>
